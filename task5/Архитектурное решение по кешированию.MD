# Архитектурное решение по кешированию

## 1. Мотивация

На текущий момент основной проблемой системы является низкая производительность MES-системы, что выражается в двух аспектах:

*   **Задержки интерфейса операторов:** Дашборд долго прогружается из-за высокой нагрузки на базу данных **MES db**, вызванной одновременно тяжелыми расчетами и частыми запросами на чтение списков заказов.
*   **Длительность бизнес-процесса:** Каждый заказ требует полного цикла расчета, даже если он типовой или состоит из повторяющихся элементов.

### Цели внедрения кеширования:

*   Снижение нагрузки на **MES db** (разгрузка CPU и IOPS).
*   Мгновенная реакция дашборда операторов при повторных заходах или пагинации.
*   Ускорение процесса оформления заказа для пользователей за счет кеширования результатов расчетов типовых моделей/элементов.

### Что будем кешировать:

*   Списки заказов для операторов (с учетом фильтров и пагинации).
*   Справочные данные (цены на материалы, коэффициенты сложности).
*   Результаты расчетов стоимости для часто используемых конфигураций в конструкторе.

## 2. Предлагаемое решение

Мы будем использовать комбинированный подход, сочетая клиентское и серверное кеширование.

### Типы кеширования

*   **Клиентское кеширование (Browser/SPA):** Для статических ресурсов (Vue/React бандлы) и HTTP-кеширование API-ответов с использованием `ETag`. Это позволит операторам не скачивать список заказов заново, если в базе ничего не изменилось.
*   **Серверное кеширование (Distributed Cache):** Внедрение **Redis** между API-сервисами и базами данных. Это необходимо для совместного использования кеша несколькими инстансами приложений в облаке.

### Выбор паттерна: Cache-Aside (Lazy Loading)

Для работы со списками заказов и результатами расчетов выбран паттерн **Cache-Aside**.

#### Почему Cache-Aside:

*   **Отказоустойчивость:** Если **Redis** выйдет из строя, система продолжит работу напрямую с БД (хотя и медленнее).
*   **Гибкость:** Мы можем кешировать только те данные, которые реально запрашиваются.
*   **Простота реализации:** Не требует сложной синхронизации на уровне кода доступа к данным.

#### Почему другие не подходят:

*   **Write-Through:** Приведет к задержкам при создании заказа, так как запись в кеш будет блокирующей. Для MES, где важна скорость фиксации статуса, это критично.
*   **Refresh-Ahead:** Трудно реализовать, так как мы не можем точно предсказать, какой именно фильтр применит оператор или какую модель создаст пользователь в конструкторе.

### Инвалидация кеша

Мы будем использовать **Программную инвалидацию (Event-based)** в сочетании с **TTL (Time-To-Live)**.

*   При изменении статуса заказа (например, с `SUBMITTED` на `PRICE_CALCULATED`), приложение **MES API** должно принудительно удалить (или обновить) ключ в **Redis**, отвечающий за список заказов данного оператора.
*   Для справочных данных (цены на золото/камни) будет использоваться **TTL** (например, 1 час), так как эти данные меняются редко.

## 3. Сравнительный анализ стратегий

| Критерий | TTL (по времени) | Программная (по событию) | Manual (вручную) |
| :--- | :--- | :--- | :--- |
| **Актуальность данных** | Возможен эффект «грязного чтения» до истечения времени. | Максимальная (данные всегда свежие). | Зависит от действий админа. |
| **Нагрузка на БД** | Низкая. | Средняя (частые инвалидации при активности). | Минимальная. |
| **Сложность реализации** | Очень низкая (один параметр). | Высокая (нужна логика в коде приложения). | Низкая. |
| **Применимость** | Идеально для цен и справочников. | Идеально для статусов заказов. | Для экстренных случаев. |







