# Архитектурное решение по трейсингу в системе «Александрит»

## 1. Идентификация проблемных зон

Для того чтобы заказы перестали «зависать» или пропадать, необходимо внедрить сквозное прохождение **Trace ID** через все компоненты системы.

Места, где заказ чаще всего «ломается» или зависает:

*   **Shop API ↔ RabbitMQ:** Сообщение о новом заказе может не дойти до очереди из-за сбоя сети или переполнения брокера.
*   **MES API (Расчет стоимости):** Самый критичный узел. Заказ может «зависнуть» на этапе расчета 3D-модели (на 30 минут) и упасть по таймауту или из-за нехватки памяти, не отправив статус обратно.
*   **RabbitMQ ↔ CRM API:** Статус `PRICE_CALCULATED` может быть потерян при передаче из MES в CRM, из-за чего менеджер не увидит готовность заказа.
*   **CRM API ↔ MES API:** Команда на начало производства (`MANUFACTURING_APPROVED`) может потеряться в очереди, и оператор никогда не увидит заказ в работе.

Системы, подлежащие покрытию трейсингом:

*   **Internet Shop** (Spring Boot) — начало пути заказа.
*   **Shop API** (Spring Boot) — оркестрация создания заказа.
*   **MES API** (C#/.NET) — расчеты и производственные этапы.
*   **CRM API** (Spring Boot) — управление жизненным циклом и статусами.
*   **RabbitMQ** — как связующее звено (инструментация через заголовки сообщений).

## 2. Данные для трейсинга (Спан-атрибуты)

Для эффективной отладки каждый «спан» (отрезок пути заказа) должен содержать:

*   `order_id` — сквозной идентификатор бизнес-сущности.
*   `customer_id` — для поиска проблем конкретного клиента.
*   `file_complexity` (для MES) — количество полигонов в 3D-модели.
*   `status_transition` — из какого статуса в какой переходит заказ (например, `SUBMITTED` -> `PRICE_CALCULATED`).
*   `error_message` — текст ошибки в случае падения.
*   `messaging.system` — идентификатор очереди в RabbitMQ.

## 3. Мотивация

Без трейсинга невозможно понять, является ли задержка заказа следствием «тяжелой» модели или системной ошибки.

Бизнес и технические метрики, на которые повлияет внедрение:

*   **MTTR (Mean Time To Repair):** Сокращение времени на поиск причины «зависшего» заказа с нескольких дней до минут.
*   **Order Loss Rate:** Снижение количества потерянных заказов до 0%.
*   **SLA Compliance:** Процент заказов, рассчитанных в нормативное время (до 30 мин).
*   **Customer Satisfaction (CSAT):** Удержание крупных API-партнеров за счет прозрачности статусов.

## 4. Предлагаемое решение

Решение базируется на стандарте **OpenTelemetry (OTel)**, что позволит не привязываться к конкретному вендору.

### Технологический стек:

*   **OpenTelemetry SDK:** Интегрируется в Java (Spring Boot) и C# (MES).
*   **Context Propagation:** Использование заголовков W3C Trace Context для передачи **Trace ID** через RabbitMQ.
*   **OTel Collector:** Единый агент, который собирает трейсы со всех сервисов и отправляет их в хранилище.
*   **Jaeger:** Система для визуализации и поиска трейсов.

### Архитектурные изменения:

1.  В каждый сервис добавляется библиотека-агент.
2.  При отправке сообщения в RabbitMQ в заголовки (headers) записывается текущий `trace_parent`.
3.  При получении сообщения MES или CRM извлекают ID из заголовка и продолжают трейс.
4.  **Интеграция с БД:** Трейсинг запросов к PostgreSQL для поиска «медленных» инстансов в MES db.

## 5. Компромиссы и ограничения

*   **Стоимость хранения:** Трейсы генерируют огромный объем данных. Для экономии на проде будет настроен **Sampling** (например, записываем 100% трейсов по API-заказам и только 10% по обычным действиям на сайте).
*   **Производительность:** Добавление трейсинга в вычислительный модуль MES может дать оверхед в 1–3%. Это приемлемо на фоне 30-минутных расчетов.
*   **Legacy-код:** Если в MES есть закрытые библиотеки для работы с 3D, мы не сможем заглянуть «внутрь» самого алгоритма, только замерить время входа и выхода.

## 6. Безопасность

*   **PII Masking:** В атрибуты трейсов запрещено записывать персональные данные (ФИО, телефоны, пароли). Только ID.
*   **RBAC:** Доступ к интерфейсу Jaeger ограничивается через LDAP/AD компании. Доступ имеют только роли Support и Developer.
*   **Network:** OTel Collector находится внутри защищенного контура VPC, внешние системы (API партнеров) не имеют к нему доступа.
